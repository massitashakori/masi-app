{"ast":null,"code":"var _jsxFileName = \"/Users/RoyalTown/Project/masi-app/src/index.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'; // Global variables\n\nconst FPS = 60; // FrameRate\n\nvar canvas = null;\nvar ctx = null;\nwindow.onload = Init;\nvar bInstantDraw = false;\nvar MOVES_PER_UPDATE = 100; //How many pixels get placed down\n\nvar bDone = false;\nvar width; //canvas width\n\nvar height; //canvas height\n\nvar colorSteps = 32;\nvar imageData;\nvar grid;\nvar colors;\nvar currentPos;\nvar prevPositions;\n\nfunction Init() {\n  canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n\n  width = '256';\n  height = '128';\n  ctx = canvas.getContext('2d');\n  imageData = ctx.createImageData(width, height); //Needed to do pixel manipulation\n\n  grid = []; //Grid for the labyrinth algorithm\n\n  colors = []; //Array of all colors\n\n  prevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n\n  for (var r = 0; r < colorSteps; r++) {\n    for (var g = 0; g < colorSteps; g++) {\n      for (var b = 0; b < colorSteps; b++) {\n        colors.push(new Color(r * 255 / (colorSteps - 1), g * 255 / (colorSteps - 1), b * 255 / (colorSteps - 1))); //Fill the array with all colors\n      }\n    }\n  }\n\n  for (var x = 0; x < width; x++) {\n    grid.push(new Array());\n\n    for (var y = 0; y < height; y++) {\n      grid[x].push(0); //Set up the grid\n    }\n  }\n\n  currentPos = new Point(Math.floor(Math.random() * width), Math.floor(Math.random() * height));\n  grid[currentPos.x][currentPos.y] = 1;\n  prevPositions.push(currentPos);\n  ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\n  if (bInstantDraw) {\n    do {\n      var notMoved = true;\n\n      while (notMoved) {\n        var availableSpaces = CheckForSpaces(grid);\n\n        if (availableSpaces.length > 0) {\n          var test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n          prevPositions.push(currentPos);\n          currentPos = test;\n          grid[currentPos.x][currentPos.y] = 1;\n          ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n          notMoved = false;\n        } else {\n          if (prevPositions.length !== 0) {\n            currentPos = prevPositions.pop();\n          } else {\n            break;\n          }\n        }\n      }\n    } while (prevPositions.length > 0);\n\n    console.warn(colors.length);\n    ctx.putImageData(imageData, 0, 0);\n  } else {\n    setInterval(GameLoop, 1000 / FPS);\n  }\n} // Main program loop\n\n\nfunction GameLoop() {\n  Update();\n  Draw();\n} // Game logic goes here\n\n\nfunction Update() {\n  if (!bDone) {\n    var counter = MOVES_PER_UPDATE;\n\n    while (counter > 0) //For speeding up the drawing\n    {\n      var notMoved = true;\n\n      while (notMoved) {\n        var availableSpaces = CheckForSpaces(grid); //Find available spaces\n\n        if (availableSpaces.length > 0) //If there are available spaces\n          {\n            prevPositions.push(currentPos); //add old position to prevPosition array\n\n            currentPos = availableSpaces[Math.floor(Math.random() * availableSpaces.length)]; //pick a random available space\n\n            grid[currentPos.x][currentPos.y] = 1; //set that space to filled\n\n            ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop()); //pop color of the array and put it in that space\n\n            notMoved = false;\n          } else {\n          if (prevPositions.length !== 0) {\n            currentPos = prevPositions.pop(); //pop to previous position where spaces are available\n          } else {\n            ctx.putImageData(imageData, 0, 0);\n            bDone = true;\n            break;\n          }\n        }\n      }\n\n      counter--;\n    }\n  }\n}\n\nfunction Draw() {\n  // Clear the screen\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); //ctx.fillStyle='#000000';\n  //ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction CheckForSpaces(inGrid) //Checks for available spaces then returns back all available spaces\n{\n  var availableSpaces = [];\n\n  if (currentPos.x > 0) {\n    if (inGrid[currentPos.x - 1][currentPos.y] === 0) {\n      availableSpaces.push(new Point(currentPos.x - 1, currentPos.y));\n    }\n  } else if (inGrid[width - 1][currentPos.y] === 0) {\n    availableSpaces.push(new Point(width - 1, currentPos.y));\n  }\n\n  if (currentPos.x < width - 1) {\n    if (inGrid[currentPos.x + 1][currentPos.y] === 0) {\n      availableSpaces.push(new Point(currentPos.x + 1, currentPos.y));\n    }\n  } else if (inGrid[0][currentPos.y] === 0) {\n    availableSpaces.push(new Point(0, currentPos.y));\n  }\n\n  if (currentPos.y > 0) {\n    if (inGrid[currentPos.x][currentPos.y - 1] === 0) {\n      availableSpaces.push(new Point(currentPos.x, currentPos.y - 1));\n    }\n  } else if (inGrid[currentPos.x][height - 1] === 0) {\n    availableSpaces.push(new Point(currentPos.x, height - 1));\n  }\n\n  if (currentPos.y < height - 1) {\n    if (inGrid[currentPos.x][currentPos.y + 1] === 0) {\n      availableSpaces.push(new Point(currentPos.x, currentPos.y + 1));\n    }\n  } else if (inGrid[currentPos.x][0] === 0) {\n    availableSpaces.push(new Point(currentPos.x, 0));\n  }\n\n  return availableSpaces;\n}\n\nfunction ChangePixel(data, x, y, color) //Quick function to simplify changing pixels\n{\n  data.data[(x + y * width) * 4 + 0] = color.r;\n  data.data[(x + y * width) * 4 + 1] = color.g;\n  data.data[(x + y * width) * 4 + 2] = color.b;\n  data.data[(x + y * width) * 4 + 3] = 255;\n}\n/*Needed Classes*/\n\n\nfunction Point(xIn, yIn) {\n  this.x = xIn;\n  this.y = yIn;\n}\n\nfunction Color(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n  this.hue = Math.atan2(Math.sqrt(3) * (this.g - this.b), 2 * this.r - this.g, this.b);\n  this.min = Math.min(this.r, this.g);\n  this.min = Math.min(this.min, this.b);\n  this.min /= 255;\n  this.max = Math.max(this.r, this.g);\n  this.max = Math.max(this.max, this.b);\n  this.max /= 255;\n  this.luminance = (this.min + this.max) / 2;\n\n  if (this.min === this.max) {\n    this.saturation = 0;\n  } else if (this.luminance < 0.5) {\n    this.saturation = (this.max - this.min) / (this.max + this.min);\n  } else if (this.luminance >= 0.5) {\n    this.saturation = (this.max - this.min) / (2 - this.max - this.min);\n  }\n}\n\nfunction RainbowImg() {\n  return React.createElement(\"canvas\", {\n    id: \"canvas\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 263\n    },\n    __self: this\n  }, \"Sorry your browser does not support Canvas, try Firefox or Chrome!\");\n}\n\nReactDOM.render(React.createElement(RainbowImg, {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 270\n  },\n  __self: this\n}), document.getElementById('root'));","map":{"version":3,"sources":["/Users/RoyalTown/Project/masi-app/src/index.js"],"names":["React","ReactDOM","FPS","canvas","ctx","window","onload","Init","bInstantDraw","MOVES_PER_UPDATE","bDone","width","height","colorSteps","imageData","grid","colors","currentPos","prevPositions","document","getElementById","getContext","createImageData","r","g","b","push","Color","x","Array","y","Point","Math","floor","random","ChangePixel","pop","notMoved","availableSpaces","CheckForSpaces","length","test","console","warn","putImageData","setInterval","GameLoop","Update","Draw","counter","clearRect","inGrid","data","color","xIn","yIn","hue","atan2","sqrt","min","max","luminance","saturation","RainbowImg","render"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n\n// Global variables\nconst FPS = 60;// FrameRate\nvar canvas = null;\nvar ctx = null;\nwindow.onload = Init;\n\nvar bInstantDraw = false;\nvar MOVES_PER_UPDATE = 100; //How many pixels get placed down\nvar bDone = false;\nvar width; //canvas width\nvar height; //canvas height\nvar colorSteps = 32;\n\nvar imageData;\nvar grid;\nvar colors;\n\nvar currentPos;\nvar prevPositions;\n\n\nfunction Init()\n{\n    canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n\twidth = '256';\n\theight = '128';\n    ctx = canvas.getContext('2d'); \n\t\n\timageData = ctx.createImageData(width,height); //Needed to do pixel manipulation\n\t\n\tgrid = []; //Grid for the labyrinth algorithm\n\tcolors = []; //Array of all colors\n\tprevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n\t\n\tfor(var r = 0; r < colorSteps; r++)\n\t{\n\t\tfor(var g = 0; g < colorSteps; g++)\n\t\t{\n\t\t\tfor(var b = 0; b < colorSteps; b++)\n\t\t\t{\n\t\t\t\tcolors.push(new Color(r * 255 / (colorSteps - 1), g * 255 / (colorSteps - 1), b * 255 / (colorSteps - 1)));\n\t\t\t\t//Fill the array with all colors\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(var x = 0; x < width; x++)\n\t{\n\n\t\tgrid.push(new Array());\n\t\tfor(var y = 0; y < height; y++)\n\t\t{\n\t\t\tgrid[x].push(0); //Set up the grid\n\t\t}\n\t}\n\t\n\tcurrentPos = new Point(Math.floor(Math.random() * width),Math.floor(Math.random() * height)); \n\t\n\tgrid[currentPos.x][currentPos.y] = 1;\n\tprevPositions.push(currentPos);\n\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\t\n\tif(bInstantDraw)\n\t{\n\t\tdo\n\t\t{\n\t\t\tvar notMoved = true;\n\t\t\twhile(notMoved)\n\t\t\t{\n\t\t\t\tvar availableSpaces = CheckForSpaces(grid);\n\t\t\t\t\n\t\t\t\tif(availableSpaces.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n\t\t\t\t\tprevPositions.push(currentPos);\n\t\t\t\t\tcurrentPos = test;\n\t\t\t\t\tgrid[currentPos.x][currentPos.y] = 1;\n\t\t\t\t\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\t\t\t\t\tnotMoved = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(prevPositions.length !== 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPos = prevPositions.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(prevPositions.length > 0)\n\t\tconsole.warn(colors.length);\n\t\tctx.putImageData(imageData,0,0);\n\t}\n\telse\n\t{\n\t\tsetInterval(GameLoop, 1000 / FPS);\n\t}\n}\n\n// Main program loop\nfunction GameLoop()\n{\n\tUpdate();\n\tDraw();\n}\n\n// Game logic goes here\nfunction Update()\n{\n\tif(!bDone)\n\t{\n\t\tvar counter = MOVES_PER_UPDATE;\n\t\twhile(counter > 0) //For speeding up the drawing\n\t\t{\n\t\t\tvar notMoved = true;\n\t\t\twhile(notMoved)\n\t\t\t{\n\t\t\t\tvar availableSpaces = CheckForSpaces(grid); //Find available spaces\n\t\t\t\t\n\t\t\t\tif(availableSpaces.length > 0) //If there are available spaces\n\t\t\t\t{\n\t\t\t\t\tprevPositions.push(currentPos); //add old position to prevPosition array\n\t\t\t\t\tcurrentPos = availableSpaces[Math.floor(Math.random() * availableSpaces.length)]; //pick a random available space\n\t\t\t\t\tgrid[currentPos.x][currentPos.y] = 1; //set that space to filled\n\t\t\t\t\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop()); //pop color of the array and put it in that space\n\t\t\t\t\tnotMoved = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(prevPositions.length !== 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPos = prevPositions.pop(); //pop to previous position where spaces are available\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.putImageData(imageData,0,0);\n\t\t\t\t\t\tbDone = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcounter--;\n\t\t}\n\t}\n}\nfunction Draw()\n{\n\t// Clear the screen\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    //ctx.fillStyle='#000000';\n    //ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\n\tctx.putImageData(imageData,0,0);\n}\n\nfunction CheckForSpaces(inGrid) //Checks for available spaces then returns back all available spaces\n{\n\tvar availableSpaces = [];\n\t\n\tif(currentPos.x > 0)\n\t{\n\t\tif(inGrid[currentPos.x - 1][currentPos.y] === 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x - 1, currentPos.y));\n\t\t}\n\t}\n\telse if(inGrid[width - 1][currentPos.y] === 0)\n\t{\n\t\tavailableSpaces.push(new Point(width - 1, currentPos.y));\n\t}\n\t\n\tif(currentPos.x < width - 1)\n\t{\n\t\tif(inGrid[currentPos.x + 1][currentPos.y] === 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x + 1, currentPos.y));\n\t\t}\n\t}\n\telse if(inGrid[0][currentPos.y] === 0)\n\t{\n\t\tavailableSpaces.push(new Point(0, currentPos.y));\n\t}\n\t\n\tif(currentPos.y > 0)\n\t{\n\t\tif(inGrid[currentPos.x][currentPos.y - 1] === 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x, currentPos.y - 1));\n\t\t}\n\t}\n\telse if(inGrid[currentPos.x][height - 1] === 0)\n\t{\n\t\tavailableSpaces.push(new Point(currentPos.x, height - 1));\n\t}\n\t\n\tif(currentPos.y < height - 1)\n\t{\n\t\tif(inGrid[currentPos.x][currentPos.y + 1] === 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x, currentPos.y + 1));\n\t\t}\n\t}\n\telse if(inGrid[currentPos.x][0] === 0)\n\t{\n\t\tavailableSpaces.push(new Point(currentPos.x, 0));\n\t}\n\t\n\treturn availableSpaces;\n}\n\nfunction ChangePixel(data, x, y, color) //Quick function to simplify changing pixels\n{\n\tdata.data[((x + (y * width)) * 4) + 0] = color.r;\n\tdata.data[((x + (y * width)) * 4) + 1] = color.g;\n\tdata.data[((x + (y * width)) * 4) + 2] = color.b;\n\tdata.data[((x + (y * width)) * 4) + 3] = 255;\n}\n\n/*Needed Classes*/\nfunction Point(xIn, yIn)\n{\n    this.x = xIn;\n    this.y = yIn;\n}\n\nfunction Color(r, g, b)\n{\n\tthis.r = r;\n\tthis.g = g;\n\tthis.b = b;\n\tthis.hue = Math.atan2(Math.sqrt(3) * (this.g - this.b), 2 * this.r - this.g, this.b);\n\tthis.min = Math.min(this.r, this.g);\n\tthis.min = Math.min(this.min, this.b);\n\tthis.min /= 255;\n\tthis.max = Math.max(this.r, this.g);\n\tthis.max = Math.max(this.max, this.b);\n\tthis.max /= 255;\n\tthis.luminance = (this.min + this.max) / 2;\n\tif(this.min === this.max)\n\t{\n\t\tthis.saturation = 0;\n\t}\n\telse if(this.luminance < 0.5)\n\t{\n\t\tthis.saturation = (this.max - this.min) / (this.max + this.min);\n\t}\n\telse if(this.luminance >= 0.5)\n\t{\n\t\tthis.saturation = (this.max - this.min) / (2 - this.max - this.min);\n\t}\n}\nfunction RainbowImg() {\n    return (\n        <canvas id='canvas' >\n            Sorry your browser does not support Canvas, try Firefox or Chrome!\n        </canvas>\n    );\n}\n\nReactDOM.render(\n    <RainbowImg />\n    , document.getElementById('root'));"]},"metadata":{},"sourceType":"module"}