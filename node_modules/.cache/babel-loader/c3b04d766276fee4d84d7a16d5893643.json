{"ast":null,"code":"var _jsxFileName = \"/Users/RoyalTown/Project/masi-app/src/index.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'; // Global variables\n\nconst FPS = 60; // FrameRate\n\nvar canvas = null;\nvar ctx = null;\nwindow.onload = Init;\nvar bInstantDraw = false;\nvar MOVES_PER_UPDATE = 100; //How many pixels get placed down\n\nvar bDone = false;\nvar width; //canvas width\n\nvar height; //canvas height\n\nvar colorSteps = 32;\nvar imageData;\nvar grid;\nvar colors;\nvar currentPos;\nvar prevPositions;\n\nfunction RainbowImg() {\n  return React.createElement(\"canvas\", {\n    id: \"canvas\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 28\n    },\n    __self: this\n  }, \"Sorry your browser does not support Canvas, try Firefox or Chrome!\");\n  this.Init();\n} // This is called when the page loads\n\n\nfunction Init() {\n  canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n\n  width = '256';\n  height = '128';\n  ctx = canvas.getContext('2d');\n  centreX = canvas.width / 2;\n  ctx.moveTo(centreX, 10);\n  imageData = ctx.createImageData(width, height); //Needed to do pixel manipulation\n\n  grid = []; //Grid for the labyrinth algorithm\n\n  colors = []; //Array of all colors\n\n  prevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n\n  for (var r = 0; r < colorSteps; r++) {\n    for (var g = 0; g < colorSteps; g++) {\n      for (var b = 0; b < colorSteps; b++) {\n        colors.push(new Color(r * 255 / (colorSteps - 1), g * 255 / (colorSteps - 1), b * 255 / (colorSteps - 1))); //Fill the array with all colors\n      }\n    }\n  }\n  /*colors.sort(function(a,b)\n  {\n  \tif (a.r < b.r)\n             return 1;\n         if (a.r > b.r)\n             return -1;\n  \tif (a.g < b.g)\n             return -1;\n         if (a.g > b.g)\n             return 1;\n  \tif (a.b < b.b)\n             return -1;\n         if (a.b > b.b)\n             return 1;\n         return 0;\n  });*/\n\n\n  for (var x = 0; x < width; x++) {\n    grid.push(new Array());\n\n    for (var y = 0; y < height; y++) {\n      grid[x].push(0); //Set up the grid\n      //ChangePixel(imageData, x, y, colors[x + (y * width)]);\n    }\n  }\n\n  currentPos = new Point(Math.floor(Math.random() * width), Math.floor(Math.random() * height));\n  grid[currentPos.x][currentPos.y] = 1;\n  prevPositions.push(currentPos);\n  ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\n  if (bInstantDraw) {\n    do {\n      var notMoved = true;\n\n      while (notMoved) {\n        var availableSpaces = CheckForSpaces(grid);\n\n        if (availableSpaces.length > 0) {\n          var test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n          prevPositions.push(currentPos);\n          currentPos = test;\n          grid[currentPos.x][currentPos.y] = 1;\n          ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n          notMoved = false;\n        } else {\n          if (prevPositions.length != 0) {\n            currentPos = prevPositions.pop();\n          } else {\n            break;\n          }\n        }\n      }\n    } while (prevPositions.length > 0);\n\n    console.warn(colors.length);\n    ctx.putImageData(imageData, 0, 0);\n  } else {\n    setInterval(GameLoop, 1000 / FPS);\n  }\n} // Main program loop\n\n\nfunction GameLoop() {\n  Update();\n  Draw();\n} // Game logic goes here\n\n\nfunction Update() {\n  if (!bDone) {\n    var counter = MOVES_PER_UPDATE;\n\n    while (counter > 0) //For speeding up the drawing\n    {\n      var notMoved = true;\n\n      while (notMoved) {\n        var availableSpaces = CheckForSpaces(grid); //Find available spaces\n\n        if (availableSpaces.length > 0) //If there are available spaces\n          {\n            prevPositions.push(currentPos); //add old position to prevPosition array\n\n            currentPos = availableSpaces[Math.floor(Math.random() * availableSpaces.length)]; //pick a random available space\n\n            grid[currentPos.x][currentPos.y] = 1; //set that space to filled\n\n            ChangePixel(imageData, currentPos.x, currentPos.y, colors.pop()); //pop color of the array and put it in that space\n\n            notMoved = false;\n          } else {\n          if (prevPositions.length != 0) {\n            currentPos = prevPositions.pop(); //pop to previous position where spaces are available\n          } else {\n            ctx.putImageData(imageData, 0, 0);\n            bDone = true;\n            break;\n          }\n        }\n      }\n\n      counter--;\n    }\n  }\n}\n\nfunction Draw() {\n  // Clear the screen\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.fillStyle = '#000000';\n  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction CheckForSpaces(inGrid) //Checks for available spaces then returns back all available spaces\n{\n  var availableSpaces = [];\n\n  if (currentPos.x > 0) {\n    if (inGrid[currentPos.x - 1][currentPos.y] == 0) {\n      availableSpaces.push(new Point(currentPos.x - 1, currentPos.y));\n    }\n  } else if (inGrid[width - 1][currentPos.y] == 0) {\n    availableSpaces.push(new Point(width - 1, currentPos.y));\n  }\n\n  if (currentPos.x < width - 1) {\n    if (inGrid[currentPos.x + 1][currentPos.y] == 0) {\n      availableSpaces.push(new Point(currentPos.x + 1, currentPos.y));\n    }\n  } else if (inGrid[0][currentPos.y] == 0) {\n    availableSpaces.push(new Point(0, currentPos.y));\n  }\n\n  if (currentPos.y > 0) {\n    if (inGrid[currentPos.x][currentPos.y - 1] == 0) {\n      availableSpaces.push(new Point(currentPos.x, currentPos.y - 1));\n    }\n  } else if (inGrid[currentPos.x][height - 1] == 0) {\n    availableSpaces.push(new Point(currentPos.x, height - 1));\n  }\n\n  if (currentPos.y < height - 1) {\n    if (inGrid[currentPos.x][currentPos.y + 1] == 0) {\n      availableSpaces.push(new Point(currentPos.x, currentPos.y + 1));\n    }\n  } else if (inGrid[currentPos.x][0] == 0) {\n    availableSpaces.push(new Point(currentPos.x, 0));\n  }\n\n  return availableSpaces;\n}\n\nfunction ChangePixel(data, x, y, color) //Quick function to simplify changing pixels\n{\n  data.data[(x + y * width) * 4 + 0] = color.r;\n  data.data[(x + y * width) * 4 + 1] = color.g;\n  data.data[(x + y * width) * 4 + 2] = color.b;\n  data.data[(x + y * width) * 4 + 3] = 255;\n}\n/*Needed Classes*/\n\n\nfunction Point(xIn, yIn) {\n  this.x = xIn;\n  this.y = yIn;\n}\n\nfunction Color(r, g, b) {\n  this.r = r;\n  this.g = g;\n  this.b = b;\n  this.hue = Math.atan2(Math.sqrt(3) * (this.g - this.b), 2 * this.r - this.g, this.b);\n  this.min = Math.min(this.r, this.g);\n  this.min = Math.min(this.min, this.b);\n  this.min /= 255;\n  this.max = Math.max(this.r, this.g);\n  this.max = Math.max(this.max, this.b);\n  this.max /= 255;\n  this.luminance = (this.min + this.max) / 2;\n\n  if (this.min === this.max) {\n    this.saturation = 0;\n  } else if (this.luminance < 0.5) {\n    this.saturation = (this.max - this.min) / (this.max + this.min);\n  } else if (this.luminance >= 0.5) {\n    this.saturation = (this.max - this.min) / (2 - this.max - this.min);\n  }\n}\n\nReactDOM.render(React.createElement(RainbowImg, {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 291\n  },\n  __self: this\n}), document.getElementById('root'));","map":{"version":3,"sources":["/Users/RoyalTown/Project/masi-app/src/index.js"],"names":["React","ReactDOM","FPS","canvas","ctx","window","onload","Init","bInstantDraw","MOVES_PER_UPDATE","bDone","width","height","colorSteps","imageData","grid","colors","currentPos","prevPositions","RainbowImg","document","getElementById","getContext","centreX","moveTo","createImageData","r","g","b","push","Color","x","Array","y","Point","Math","floor","random","ChangePixel","pop","notMoved","availableSpaces","CheckForSpaces","length","test","console","warn","putImageData","setInterval","GameLoop","Update","Draw","counter","clearRect","fillStyle","fillRect","inGrid","data","color","xIn","yIn","hue","atan2","sqrt","min","max","luminance","saturation","render"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n\n// Global variables\nconst FPS = 60;// FrameRate\nvar canvas = null;\nvar ctx = null;\nwindow.onload = Init;\n\nvar bInstantDraw = false;\nvar MOVES_PER_UPDATE = 100; //How many pixels get placed down\nvar bDone = false;\nvar width; //canvas width\nvar height; //canvas height\nvar colorSteps = 32;\n\nvar imageData;\nvar grid;\nvar colors;\n\nvar currentPos;\nvar prevPositions;\n\nfunction RainbowImg() {\n    return (\n        <canvas id='canvas' >\n            Sorry your browser does not support Canvas, try Firefox or Chrome!\n        </canvas>\n    );\n    this.Init();\n}\n// This is called when the page loads\nfunction Init()\n{\n    canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n\twidth = '256';\n\theight = '128';\n    ctx = canvas.getContext('2d'); \n    centreX = canvas.width / 2;\n    ctx.moveTo(centreX, 10);\n\t\n\timageData = ctx.createImageData(width,height); //Needed to do pixel manipulation\n\t\n\tgrid = []; //Grid for the labyrinth algorithm\n\tcolors = []; //Array of all colors\n\tprevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n\t\n\tfor(var r = 0; r < colorSteps; r++)\n\t{\n\t\tfor(var g = 0; g < colorSteps; g++)\n\t\t{\n\t\t\tfor(var b = 0; b < colorSteps; b++)\n\t\t\t{\n\t\t\t\tcolors.push(new Color(r * 255 / (colorSteps - 1), g * 255 / (colorSteps - 1), b * 255 / (colorSteps - 1)));\n\t\t\t\t//Fill the array with all colors\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*colors.sort(function(a,b)\n\t{\n\t\tif (a.r < b.r)\n            return 1;\n        if (a.r > b.r)\n            return -1;\n\t\tif (a.g < b.g)\n            return -1;\n        if (a.g > b.g)\n            return 1;\n\t\tif (a.b < b.b)\n            return -1;\n        if (a.b > b.b)\n            return 1;\n        return 0;\n\t});*/\n\t\n\tfor(var x = 0; x < width; x++)\n\t{\n\t\tgrid.push(new Array());\n\t\tfor(var y = 0; y < height; y++)\n\t\t{\n\t\t\tgrid[x].push(0); //Set up the grid\n\t\t\t//ChangePixel(imageData, x, y, colors[x + (y * width)]);\n\t\t}\n\t}\n\t\n\tcurrentPos = new Point(Math.floor(Math.random() * width),Math.floor(Math.random() * height)); \n\t\n\tgrid[currentPos.x][currentPos.y] = 1;\n\tprevPositions.push(currentPos);\n\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\t\n\tif(bInstantDraw)\n\t{\n\t\tdo\n\t\t{\n\t\t\tvar notMoved = true;\n\t\t\twhile(notMoved)\n\t\t\t{\n\t\t\t\tvar availableSpaces = CheckForSpaces(grid);\n\t\t\t\t\n\t\t\t\tif(availableSpaces.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n\t\t\t\t\tprevPositions.push(currentPos);\n\t\t\t\t\tcurrentPos = test;\n\t\t\t\t\tgrid[currentPos.x][currentPos.y] = 1;\n\t\t\t\t\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop());\n\t\t\t\t\tnotMoved = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(prevPositions.length != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPos = prevPositions.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(prevPositions.length > 0)\n\t\tconsole.warn(colors.length);\n\t\tctx.putImageData(imageData,0,0);\n\t}\n\telse\n\t{\n\t\tsetInterval(GameLoop, 1000 / FPS);\n\t}\n}\n\n// Main program loop\nfunction GameLoop()\n{\n\tUpdate();\n\tDraw();\n}\n\n// Game logic goes here\nfunction Update()\n{\n\tif(!bDone)\n\t{\n\t\tvar counter = MOVES_PER_UPDATE;\n\t\twhile(counter > 0) //For speeding up the drawing\n\t\t{\n\t\t\tvar notMoved = true;\n\t\t\twhile(notMoved)\n\t\t\t{\n\t\t\t\tvar availableSpaces = CheckForSpaces(grid); //Find available spaces\n\t\t\t\t\n\t\t\t\tif(availableSpaces.length > 0) //If there are available spaces\n\t\t\t\t{\n\t\t\t\t\tprevPositions.push(currentPos); //add old position to prevPosition array\n\t\t\t\t\tcurrentPos = availableSpaces[Math.floor(Math.random() * availableSpaces.length)]; //pick a random available space\n\t\t\t\t\tgrid[currentPos.x][currentPos.y] = 1; //set that space to filled\n\t\t\t\t\tChangePixel(imageData, currentPos.x, currentPos.y, colors.pop()); //pop color of the array and put it in that space\n\t\t\t\t\tnotMoved = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(prevPositions.length != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPos = prevPositions.pop(); //pop to previous position where spaces are available\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.putImageData(imageData,0,0);\n\t\t\t\t\t\tbDone = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcounter--;\n\t\t}\n\t}\n}\nfunction Draw()\n{\n\t// Clear the screen\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.fillStyle='#000000';\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\n\tctx.putImageData(imageData,0,0);\n}\n\nfunction CheckForSpaces(inGrid) //Checks for available spaces then returns back all available spaces\n{\n\tvar availableSpaces = [];\n\t\n\tif(currentPos.x > 0)\n\t{\n\t\tif(inGrid[currentPos.x - 1][currentPos.y] == 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x - 1, currentPos.y));\n\t\t}\n\t}\n\telse if(inGrid[width - 1][currentPos.y] == 0)\n\t{\n\t\tavailableSpaces.push(new Point(width - 1, currentPos.y));\n\t}\n\t\n\tif(currentPos.x < width - 1)\n\t{\n\t\tif(inGrid[currentPos.x + 1][currentPos.y] == 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x + 1, currentPos.y));\n\t\t}\n\t}\n\telse if(inGrid[0][currentPos.y] == 0)\n\t{\n\t\tavailableSpaces.push(new Point(0, currentPos.y));\n\t}\n\t\n\tif(currentPos.y > 0)\n\t{\n\t\tif(inGrid[currentPos.x][currentPos.y - 1] == 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x, currentPos.y - 1));\n\t\t}\n\t}\n\telse if(inGrid[currentPos.x][height - 1] == 0)\n\t{\n\t\tavailableSpaces.push(new Point(currentPos.x, height - 1));\n\t}\n\t\n\tif(currentPos.y < height - 1)\n\t{\n\t\tif(inGrid[currentPos.x][currentPos.y + 1] == 0)\n\t\t{\n\t\t\tavailableSpaces.push(new Point(currentPos.x, currentPos.y + 1));\n\t\t}\n\t}\n\telse if(inGrid[currentPos.x][0] == 0)\n\t{\n\t\tavailableSpaces.push(new Point(currentPos.x, 0));\n\t}\n\t\n\treturn availableSpaces;\n}\n\nfunction ChangePixel(data, x, y, color) //Quick function to simplify changing pixels\n{\n\tdata.data[((x + (y * width)) * 4) + 0] = color.r;\n\tdata.data[((x + (y * width)) * 4) + 1] = color.g;\n\tdata.data[((x + (y * width)) * 4) + 2] = color.b;\n\tdata.data[((x + (y * width)) * 4) + 3] = 255;\n}\n\n/*Needed Classes*/\nfunction Point(xIn, yIn)\n{\n    this.x = xIn;\n    this.y = yIn;\n}\n\nfunction Color(r, g, b)\n{\n\tthis.r = r;\n\tthis.g = g;\n\tthis.b = b;\n\tthis.hue = Math.atan2(Math.sqrt(3) * (this.g - this.b), 2 * this.r - this.g, this.b);\n\tthis.min = Math.min(this.r, this.g);\n\tthis.min = Math.min(this.min, this.b);\n\tthis.min /= 255;\n\tthis.max = Math.max(this.r, this.g);\n\tthis.max = Math.max(this.max, this.b);\n\tthis.max /= 255;\n\tthis.luminance = (this.min + this.max) / 2;\n\tif(this.min === this.max)\n\t{\n\t\tthis.saturation = 0;\n\t}\n\telse if(this.luminance < 0.5)\n\t{\n\t\tthis.saturation = (this.max - this.min) / (this.max + this.min);\n\t}\n\telse if(this.luminance >= 0.5)\n\t{\n\t\tthis.saturation = (this.max - this.min) / (2 - this.max - this.min);\n\t}\n}\n\n\nReactDOM.render(\n    <RainbowImg />\n    , document.getElementById('root'));"]},"metadata":{},"sourceType":"module"}